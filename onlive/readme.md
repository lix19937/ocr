## 直播间背后的图像技术


### 脸更白 
* demo   
![skin_whitening](https://github.com/lix19937/opencv-cookbook/assets/38753233/7a02ea4a-8d32-4ab8-bbcc-2eca9a9fce32)    



* 干货   
经过**磨皮**处理，也就是把痘、斑这些消除掉。然后把经过磨皮的图片与原图进行**混合**。混合这个步骤是不可缺少的，如果只用磨皮后的图，很容易丢失细节。把两张图混合，还可以通过**调整两个图的混合权重，来控制磨皮的程度**，达成不同级别的磨皮效果。最后一步也很关键，**美肤**，比如把皮肤肤色调得白一点、红嫩一点，或者一些特殊的需求。   
**磨皮**——去痘就是降噪本质上说，一张图就是一个二维的数据。如果相临的两个区域灰度值相差比较大，这就意味着存在着噪点。比如脸上有个痘，这个痘自然产生一个灰度值的变化，从抽象意义上说就是一个噪点。所以美颜磨皮的算法，核心是去噪。去噪有很多的办法，美颜的去噪算法都要保持一个特点，那就既要是边界保持，同时还要做到平滑，也就是要滤波。**滤波算法**中比较常见的是**双边滤波**。  
**肤色调整**——在做好磨皮后，最后一个流程就是肤色调整，重点在于肤色检测。  
肤色检测特殊的地方在于颜色空间的转换。因为跟图像处理相关的颜色空间主要有三种：RGB、YUV、HSV，而这三种色彩空间在直播中都要用到。  
RGB是最常见的色彩空间，常用的显示设备就是基于RGB空间。  
YUV是一种比较传统的颜色空间，最早是应用在电视信号的传播里面的，目前多用在直播的数据采样、传输的过程。这是因为人眼对亮度（Y）远比色度(U、V)更敏感，所以YUV比起RGB更容易被压缩，节省带宽进行传输。   
基于HSV颜色空间才是用来做肤色检测的。因为如果用RGB来做肤色检测，需要检测R、G、B三个值是否同时满足肤色的颜色范围，YUV同理。而HSV三个值：色调（H）、饱和度（S），明度（V）中，只有H是关乎肤色的，因此只需要对H进行考虑（H值在25-50之间即可判断为肤色），所需要的运算量自然比RGB少很多。
所以，在直播的不同阶段，要分别使用这三种色彩空间，要不停的把这三种色彩空间进行相互转换。

### 脸更瘦  
* demo

|before  | after |
|--------|------ |
|![left](https://github.com/lix19937/opencv-cookbook/assets/38753233/5ce32176-2266-4670-9e56-40e1f007dc33) | ![right](https://github.com/lix19937/opencv-cookbook/assets/38753233/dd4da294-582c-4dfe-96c4-bdfa71b00c71)|

* 干货   
**瘦脸**：让脸部变得瘦削。从图像处理的角度来说它将脸部轮廓周围的图像进行收缩操作，同时还要确保收缩后图像分布连续。是一种非线性变形的算法。脸部区域的图像呈现朝中心区域收缩的趋势，因此需要先确定一个收缩的中心点。借助人脸关键点的检测结果，可以将索引30的点（鼻子区域）作为收缩中心点。之后对于脸部边缘区域，可以确定收缩区域的圆心与半径，对于园内的每个像素，其收缩方向为该像素指向收缩中心，且距离圆心越近的点收缩力度越大，所以位于圆的边缘点不会收缩。    

### 眼更大     
* demo  


* 干货    
大眼的操作就是使得眼睛区域的图像内容进行一定的放缩处理，它属于局部变形操作。常用的图像变形操作有平移、旋转、缩放、裁切等，大眼操作乍看和上述的处理不同，但其本质相同——图像的**重映射**。利用某种映射关系，根据原图计算目标图的组成内容。
实际操作中会计算目标图像中每个像素点对应到原图的像素坐标，逐点计算目标图的(u,v)映射到原图的坐标(u',v')。但一般得到的(u',v')不是整数，需要通过**插值**操作计算得到其像素值。常用的插值方法有很多，这里主要介绍常见的三种方法：最近邻、双线性、双三次。    
注意：简单的将图像进行放大无法实现大眼的功能。
仔细分析，大眼功能有两方面要求：
1, 眼部区域放大；
2, 放大区域的图像边缘与未处理区域自然过渡。  
可以规定处理区域为眼睛为圆心的一个圆形，从圆心区域开始图像会放大，但该放大的比例随着距离圆心的距离而变小，直至边缘区域的放大比例为0。这样做就使得眼睛得到放大同时放大后的区域还能够与原图自然连接。将上述描述量化表达，以r代表上述变形区域的圆的半径，X表示原始图像像素到变形圆圆心的距离，Y表示像素变形后的其距离变形圆圆心的距离，则其形状大致如下图所示。如果希望图像不变，其函数曲线就是y=x的一条直线；如果希望图像放大，则该曲线将位于y=x直线的上方；反之曲线位于y=x直线下方时表示图像缩小。在实际图像变形操作中要从目标图像映射到原图，因此需要将X/Y调换，让X表示变形后图像的像素距离变形圆中心的距离，Y表示原图像素距离变形圆中心的距离。

### 腿更长  
* demo  


* 干货

### 变老  
* demo  


* 干货   
主要就是添加**面部皱纹**     
  
### 换脸 
* demo  


* 干货

 
### 戴皇冠  
* demo  


* 干货

### 捏小脸     
* demo  


* 干货


### 火箭飘   
* demo  


* 干货

### 虚拟背景    
* demo  


* 干货   
https://baijiahao.baidu.com/s?id=1709254995162392699&wfr=spider&for=pc


### 瞬变装  
* demo  


* 干货   


### 虚拟人    
* demo  


* 干货     
http://news.sohu.com/a/654039850_441383   


### 低照度图像增强     
* demo  


* 干货    
参考使用Photoshop拉亮低照度图像的方法，按照教程介绍，使用Photoshop操作一遍，觉得效果还可以。做图像算法可以参考Photoshop用法，有时候图像算法就是把Photoshop上面的处理图像步骤程序化一下。本文介绍的低照度图像增强算法基本可以分2步：
将绿色通道反色后作为系数值，分别与各个通道相乘，得到新图层；
将新图层与原图做一次滤色混合，f(a, b) = 1 - (1 - a)*(1 - b)；
如果觉得增强程度不够，可以多做几次图层滤色操作。





